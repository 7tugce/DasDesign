(function() {
  var HTMLExtractor, _isArray, _isEmpty, _isString, htmlparser,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  htmlparser = require("htmlparser2");

  _isEmpty = require('lodash/isEmpty');

  _isString = require('lodash/isString');

  _isArray = require('lodash/isArray');

  module.exports = HTMLExtractor = (function() {

    /*
    	## constructor
    	
    	`new HTMLExtractor( debug )`
    	
    	initializes a extractor instance
    	
    	@param { Boolean } [debug=false] Output the parsing time
     */
    function HTMLExtractor(debug) {
      this.debug = debug != null ? debug : false;
      this._extract = bind(this._extract, this);
      this.extract = bind(this.extract, this);
      this._trim = bind(this._trim, this);
      return;
    }

    HTMLExtractor.prototype._trimRegex = /^\s+/;


    /*
    	## _trim
    	
    	`html_extractor._trim( str )`
    	
    	Trim method to remove whitespace
    	
    	@param { String } [str=""] String to trim
    	
    	@return { String } Trimmed string
    	
    	@api private
     */

    HTMLExtractor.prototype._trim = function(str) {
      var i;
      if (str == null) {
        str = "";
      }
      str = str.replace(this._trimRegex, "");
      i = str.length - 1;
      while (i >= 0) {
        if (/\S/.test(str.charAt(i))) {
          str = str.substring(0, i + 1);
          break;
        }
        i--;
      }
      return str;
    };


    /*
    	## extract
    	
    	`html_extractor.extract( html[, reduce], cb )`
    	
    	Main method to extract the contens out of a html string
    	
    	@param { String } html Raw html string to extract the meta, title and body
    	@param { Object } [reduce] Reduce config object to reduce the body results to a specific element. Example: `{ tag: "div", attr: "id", val: "myContent" }`
    	@param { Function } reduce Callback function
    	
    	@api public
     */

    HTMLExtractor.prototype.extract = function() {
      var _ret, arg, cb, html, j, reduce;
      arg = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), cb = arguments[j++];
      html = arg[0], reduce = arg[1];
      _ret = {
        meta: {
          title: "",
          description: "",
          keywords: ""
        },
        body: null,
        h1: []
      };
      if (this.debug) {
        console.time("\t\tparse Time");
      }
      this._extract(html, _ret, reduce, (function(_this) {
        return function(err, data) {
          var _h, idx, k, l, len, len1, listEl, ref, ref1, ref2, ref3, ref4, ref5;
          if (err) {
            cb(err);
            return;
          }
          if (_this.debug) {
            console.timeEnd("\t\tparse Time");
          }
          if ((ref = _ret.meta) != null ? (ref1 = ref.title) != null ? ref1.length : void 0 : void 0) {
            _ret.meta.title = _this._trim(_ret.meta.title);
          }
          if ((ref2 = _ret.meta) != null ? (ref3 = ref2.description) != null ? ref3.length : void 0 : void 0) {
            _ret.meta.description = _this._trim(_ret.meta.description);
          }
          if (_isString(_ret.body) && _ret.body.length) {
            _ret.body = _this._trim(_ret.body);
          } else if (_isArray(_ret.body) && _ret.body.length) {
            ref4 = _ret.body;
            for (idx = k = 0, len = ref4.length; k < len; idx = ++k) {
              listEl = ref4[idx];
              if (listEl != null ? listEl.length : void 0) {
                _ret.body[idx] = _this._trim(listEl);
              }
            }
          }
          ref5 = _ret.h1;
          for (idx = l = 0, len1 = ref5.length; l < len1; idx = ++l) {
            _h = ref5[idx];
            if (_h != null ? _h.length : void 0) {
              _ret.h1[idx] = _this._trim(_h);
            }
          }
          cb(null, data);
        };
      })(this));
    };

    HTMLExtractor.prototype._extract = function(html, _ret, reduce, cb) {
      var _body, _bodyMode, _currTag, _h1LastOpen, _h1Open, _reduce_stack, _reducedBody, _reducedBodyIdx, _scriptMode, _startBody, parser;
      if (((reduce != null ? reduce.tag : void 0) == null) || (reduce.attr == null) || (reduce.val == null)) {
        reduce = null;
      }
      if ((reduce != null ? reduce.list : void 0) != null) {
        reduce.list = true;
      }
      _bodyMode = false;
      _scriptMode = false;
      _reducedBody = [];
      _reducedBodyIdx = 0;
      _reduce_stack = null;
      _body = [];
      _currTag = null;
      _startBody = null;
      _h1Open = false;
      _h1LastOpen = false;
      parser = new htmlparser.Parser({
        onopentag: function(name, attr) {
          var ref;
          _currTag = name;
          if ((reduce != null) && reduce.tag === name && ((ref = attr[reduce.attr]) != null ? ref.indexOf(reduce.val) : void 0) >= 0) {
            _reducedBody[_reducedBodyIdx] = "";
            _reduce_stack = parser._stack.slice(0, -1).join("§§");
          }
          switch (name) {
            case "meta":
              if ((attr != null) && (attr.name != null) && (attr.content != null)) {
                _ret.meta[attr.name] = attr.content;
              } else if ((attr != null) && (attr.charset != null)) {
                _ret.meta.charset = attr.charset;
              }
              break;
            case "body":
              _bodyMode = true;
              _startBody = parser._tokenizer._index;
              break;
            case "script":
            case "style":
              _scriptMode = true;
              break;
            case "h1":
              _h1Open = true;
          }
        },
        ontext: (function(_this) {
          return function(text) {
            if (_bodyMode && !_scriptMode) {
              if ((reduce != null) && (_reduce_stack != null)) {
                _body.push(text);
                _reducedBody[_reducedBodyIdx] += text;
              } else if (reduce == null) {
                _body.push(text);
              }
            }
            if (_h1Open) {
              if (_h1LastOpen) {
                _ret.h1[_ret.h1.length - 1] += text;
              } else {
                _ret.h1.push(text);
              }
              _h1LastOpen = true;
            } else {
              _h1LastOpen = false;
            }
            switch (_currTag) {
              case "title":
                _ret.meta.title += text;
            }
          };
        })(this),
        onclosetag: function(name) {
          _currTag = null;
          if ((_reduce_stack != null) && _reduce_stack === parser._stack.join("§§")) {
            _reducedBodyIdx++;
            _reduce_stack = null;
          }
          switch (name) {
            case "body":
              if (_startBody < parser._tokenizer._index) {
                _bodyMode = false;
              }
              break;
            case "h1":
              _h1Open = false;
              _h1LastOpen = false;
              break;
            case "script":
            case "style":
              _scriptMode = false;
          }
          return;
        },
        onend: (function(_this) {
          return function() {
            var _redTxt, _word, j, len;
            if (_ret.meta.keywords != null) {
              _ret.meta.keywords = (function() {
                var j, len, ref, results;
                ref = _ret.meta.keywords.split(",");
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  _word = ref[j];
                  if (!_isEmpty(_word)) {
                    results.push(this._trim(_word));
                  }
                }
                return results;
              }).call(_this);
            }
            if ((reduce != null ? reduce.list : void 0) != null) {
              _ret.body = [];
              for (j = 0, len = _reducedBody.length; j < len; j++) {
                _redTxt = _reducedBody[j];
                _redTxt = _this._trim(_redTxt).replace(/\s\s+/g, " ");
                if (_redTxt.length) {
                  _ret.body.push(_redTxt);
                }
              }
            } else {
              _ret.body = _body.join(" ").replace(/\s\s+/g, " ");
            }
            cb(null, _ret);
          };
        })(this)
      }, {
        lowerCaseTags: true,
        decodeEntities: true
      });
      parser.write(html);
      parser.end();
    };

    return HTMLExtractor;

  })();

}).call(this);
